

# DDD分层架构与数据转换规范

## ⚠️ 重要提醒：实体设计强制要求

**在创建任何领域实体之前，请务必阅读以下要求：**

### **强制要求（违反将导致代码审查失败）**

1. **所有领域实体必须继承BaseEntity**：
   ```python
   from app.common.domain.entities.base_entity import BaseEntity
   
   class Customer(BaseEntity):  # ✅ 必须继承
       pass
   ```

2. **必须调用父类构造函数**：
   ```python
   def __init__(self, id: str, name: str):
       super().__init__(id)  # ✅ 必须调用
       self._name = name
   ```

3. **必须实现validate方法**：
   ```python
   def validate(self) -> None:  # ✅ 必须实现
       if not self.name:
           raise ValueError("名称不能为空")
   ```

4. **使用工厂方法创建实体**：
   ```python
   @classmethod
   def create(cls, name: str) -> "Customer":
       customer = cls(id=customer_id(), name=name)
       customer.validate()  # ✅ 创建后必须验证
       return customer
   ```

**详细规范请参考第8.2节和第11.2节**

---

## 1. DDD分层架构

### 1.1 分层结构
```
┌─────────────────────────────────────┐
│           Presentation Layer        │ ← API Controllers, WebSocket Handlers, Dependencies
├─────────────────────────────────────┤
│         Application Layer           │ ← Application Services, Use Cases
├─────────────────────────────────────┤
│           Domain Layer              │ ← Domain Services, Aggregates, Value Objects
├─────────────────────────────────────┤
│        Infrastructure Layer         │ ← Repositories, External Services, ORM
└─────────────────────────────────────┘
```

### 1.2 各层职责

#### **Presentation Layer（表现层）**
- **职责**：处理HTTP请求、WebSocket消息、参数校验、权限控制
- **原则**：薄层，只负责请求路由和响应格式化
- **禁止**：直接操作领域对象或基础设施

#### **Application Layer（应用层）**
- **职责**：编排领域服务，实现用例，事务管理
- **原则**：无状态，协调领域对象完成业务用例
- **特点**：包含应用服务（Application Services）和用例（Use Cases）

#### **Domain Layer（领域层）**
- **职责**：核心业务逻辑，领域规则，领域事件
- **组成**：
  - **聚合根（Aggregate Root）**：业务一致性边界
  - **实体（Entity）**：有身份的对象
  - **值对象（Value Object）**：无身份的对象
  - **领域服务（Domain Service）**：跨聚合的业务逻辑
  - **领域事件（Domain Event）**：领域内的重要事件

#### **Infrastructure Layer（基础设施层）**
- **职责**：数据持久化，外部服务集成，技术实现
- **组成**：仓储实现、外部API客户端、消息队列等

## 2. 应用服务设计模式

### 2.1 统一应用服务模式（推荐）

#### **设计理念**
为了简化开发者体验，推荐使用统一的应用服务模式，将相关功能整合到一个服务中：

```python
class ChatApplicationService(IChatApplicationService):
    """统一的聊天应用服务 - 简化开发者体验"""
    
    def __init__(
        self,
        conversation_repository: IConversationRepository,
        message_repository: IMessageRepository,
        conversation_domain_service: IConversationDomainService,
        message_domain_service: IMessageDomainService,
        broadcasting_service: Optional[BroadcastingService] = None
    ):
        self.conversation_repository = conversation_repository
        self.message_repository = message_repository
        self.conversation_domain_service = conversation_domain_service
        self.message_domain_service = message_domain_service
        self.broadcasting_service = broadcasting_service
    
    # 会话管理用例
    async def create_conversation(self, title: str, owner_id: str, conversation_type: str = "single") -> ConversationInfo:
        """创建会话用例"""
        conversation = await self.conversation_domain_service.create_conversation(title, owner_id, conversation_type)
        saved_conversation = await self.conversation_repository.save(conversation)
        return ConversationConverter.to_response(saved_conversation)
    
    # 消息管理用例
    async def send_message(self, conversation_id: str, content: Any, message_type: str, sender_id: str, sender_type: str) -> MessageInfo:
        """发送消息用例"""
        # 验证会话访问权限
        if not await self.conversation_domain_service.verify_access(conversation_id, sender_id, sender_type):
            raise ValueError("无权访问此会话")
        
        # 创建消息
        message = await self.message_domain_service.create_text_message(conversation_id, content, sender_id, sender_type)
        saved_message = await self.message_repository.save(message)
        
        # 更新会话消息数
        updated_conversation = await self.conversation_domain_service.increment_message_count(conversation_id)
        if updated_conversation:
            await self.conversation_repository.save(updated_conversation)
        
        # 广播消息
        if self.broadcasting_service:
            await self.broadcasting_service.broadcast_message(conversation_id, saved_message)
        
        return MessageConverter.to_response(saved_message)
```

#### **优势**
- **简化开发者体验**：一个限界上下文使用一个服务处理所有相关功能
- **减少抉择难度**：不再需要在多个应用服务之间选择
- **统一接口**：所有相关功能都通过同一个服务提供
- **保持DDD原则**：仍然遵循领域驱动设计的分层架构

#### **适用场景**
- **单一业务领域**：如聊天、用户管理、订单管理等
- **功能紧密相关**：多个功能之间有强关联关系
- **团队规模较小**：便于统一管理和维护

## 3. 依赖注入配置

### 3.1 依赖注入最佳实践

#### **依赖注入配置**
创建专门的依赖注入模块：

```python
# api/app/{domain}/deps/{domain}.py
from typing import Optional
from fastapi import Depends
from sqlalchemy.orm import Session

from app.db.base import get_db
from app.{domain}.application import {Domain}ApplicationService
from app.{domain}.domain import {Domain}DomainService
from app.{domain}.infrastructure.repositories import {Domain}Repository
from app.websocket.broadcasting_factory import get_broadcasting_service

def get_{domain}_repository(db: Session = Depends(get_db)) -> {Domain}Repository:
    """获取{domain}仓储实例"""
    return {Domain}Repository(db)

def get_{domain}_domain_service(
    {domain}_repository: {Domain}Repository = Depends(get_{domain}_repository)
) -> {Domain}DomainService:
    """获取{domain}领域服务实例"""
    return {Domain}DomainService({domain}_repository)

def get_{domain}_application_service(
    {domain}_repository: {Domain}Repository = Depends(get_{domain}_repository),
    {domain}_domain_service: {Domain}DomainService = Depends(get_{domain}_domain_service),
    broadcasting_service: Optional[BroadcastingService] = Depends(get_broadcasting_service)
) -> {Domain}ApplicationService:
    """获取{domain}应用服务实例"""
    return {Domain}ApplicationService(
        {domain}_repository={domain}_repository,
        {domain}_domain_service={domain}_domain_service,
        broadcasting_service=broadcasting_service
    )
```

#### **避免循环依赖**
- **依赖注入**：使用FastAPI的依赖注入避免循环依赖
- **接口抽象**：使用抽象接口而不是具体实现
- **依赖方向**：确保依赖方向指向领域层

#### **生命周期管理**
- **单例模式**：对于无状态服务使用单例
- **工厂模式**：对于有状态服务使用工厂
- **作用域管理**：合理管理依赖的作用域

## 4. 错误处理分层策略

### 4.1 分层错误处理原则

#### **表现层错误处理**
表现层负责捕获和转换异常，提供统一的错误响应：

```python
@router.post("/conversations", response_model=ConversationInfo)
async def create_conversation(
    conversation_in: ConversationCreate,
    current_user: User = Depends(get_current_user),
    chat_app_service: ChatApplicationService = Depends(get_chat_application_service)
):
    """创建新会话 - 表现层只负责请求路由和响应格式化"""
    try:
        conversation = await chat_app_service.create_conversation(
            title=conversation_in.title,
            owner_id=str(current_user.id),
            conversation_type=conversation_in.conversation_type
        )
        return conversation
        
    except ValueError as e:
        # 业务逻辑错误 - 400 Bad Request
        raise HTTPException(status_code=400, detail=str(e))
    except PermissionError as e:
        # 权限错误 - 403 Forbidden
        raise HTTPException(status_code=403, detail=str(e))
    except Exception as e:
        # 系统错误 - 500 Internal Server Error
        logger.error(f"创建会话失败: {e}")
        raise HTTPException(status_code=500, detail="创建会话失败")
```

#### **应用层错误处理**
应用层抛出领域异常，不处理HTTP状态码：

```python
class ChatApplicationService(IChatApplicationService):
    async def create_conversation(self, title: str, owner_id: str, conversation_type: str = "single") -> ConversationInfo:
        """创建会话用例"""
        try:
            # 领域逻辑验证
            if not title or not title.strip():
                raise ValueError("会话标题不能为空")
            
            # 调用领域服务
            conversation = await self.conversation_domain_service.create_conversation(title, owner_id, conversation_type)
            saved_conversation = await self.conversation_repository.save(conversation)
            
            return ConversationConverter.to_response(saved_conversation)
            
        except ValueError:
            # 重新抛出业务异常
            raise
        except Exception as e:
            # 记录系统异常并重新抛出
            logger.error(f"应用服务创建会话失败: {e}")
            raise
```

#### **领域层错误处理**
领域层抛出具体的领域异常：

```python
class ConversationDomainService(IConversationDomainService):
    async def create_conversation(self, title: str, owner_id: str, conversation_type: str = "single") -> Conversation:
        """创建会话 - 领域逻辑"""
        # 领域规则验证
        if not title or not title.strip():
            raise ValueError("会话标题不能为空")
        
        if not owner_id:
            raise ValueError("会话所有者不能为空")
        
        # 检查用户是否已有同名会话
        if await self.conversation_repository.exists_by_title_and_owner(title.strip(), owner_id):
            raise ValueError(f"会话标题 '{title}' 已存在")
        
        # 创建领域对象
        conversation = Conversation.create(
            title=title.strip(),
            owner_id=owner_id,
            conversation_type=conversation_type
        )
        
        return conversation
```

### 4.2 统一错误响应格式

#### **错误响应Schema**
```python
class ErrorResponse(BaseModel):
    error: str
    message: str
    details: Optional[Dict[str, Any]] = None
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    request_id: Optional[str] = None

class ValidationErrorResponse(BaseModel):
    error: str = "validation_error"
    message: str
    field_errors: List[Dict[str, str]]
    timestamp: datetime = Field(default_factory=datetime.utcnow)
```

#### **全局异常处理器**
```python
from fastapi import Request
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError

@app.exception_handler(ValueError)
async def value_error_handler(request: Request, exc: ValueError):
    """处理业务逻辑错误"""
    return JSONResponse(
        status_code=400,
        content=ErrorResponse(
            error="business_error",
            message=str(exc),
            request_id=request.headers.get("X-Request-ID")
        ).dict()
    )

@app.exception_handler(RequestValidationError)
async def validation_error_handler(request: Request, exc: RequestValidationError):
    """处理请求验证错误"""
    field_errors = []
    for error in exc.errors():
        field_errors.append({
            "field": ".".join(str(loc) for loc in error["loc"]),
            "message": error["msg"]
        })
    
    return JSONResponse(
        status_code=422,
        content=ValidationErrorResponse(
            message="请求参数验证失败",
            field_errors=field_errors,
            request_id=request.headers.get("X-Request-ID")
        ).dict()
    )
```

## 5. WebSocket集成架构

### 5.1 WebSocket在DDD架构中的位置

#### **架构设计**
WebSocket服务位于表现层，与HTTP API并列：

```
┌─────────────────────────────────────┐
│           Presentation Layer        │ ← HTTP Controllers + WebSocket Handlers
├─────────────────────────────────────┤
│         Application Layer           │ ← Application Services
├─────────────────────────────────────┤
│           Domain Layer              │ ← Domain Services + Entities
├─────────────────────────────────────┤
│        Infrastructure Layer         │ ← Repositories + Broadcasting Service
└─────────────────────────────────────┘
```

#### **WebSocket处理器实现**
```python
# api/app/{domain}/endpoints/{domain}.py
from fastapi import WebSocket, WebSocketDisconnect, Depends
from app.core.security import get_current_user_ws
from app.{domain}.application import {Domain}ApplicationService

@router.websocket("/ws/{conversation_id}")
async def websocket_endpoint(
    websocket: WebSocket,
    conversation_id: str,
    current_user: User = Depends(get_current_user_ws),
    {domain}_app_service: {Domain}ApplicationService = Depends(get_{domain}_application_service)
):
    """WebSocket连接处理"""
    await websocket.accept()
    
    try:
        # 验证用户对会话的访问权限
        if not await {domain}_app_service.verify_conversation_access(conversation_id, str(current_user.id)):
            await websocket.close(code=4003, reason="无权访问此会话")
            return
        
        # 加入会话房间
        await {domain}_app_service.join_conversation_room(conversation_id, str(current_user.id), websocket)
        
        # 处理消息
        while True:
            data = await websocket.receive_json()
            message_type = data.get("type")
            
            if message_type == "message":
                # 处理用户消息
                message = await {domain}_app_service.send_message(
                    conversation_id=conversation_id,
                    content=data.get("content"),
                    message_type="text",
                    sender_id=str(current_user.id),
                    sender_type="customer"
                )
                
                # 广播消息给会话中的所有用户
                await {domain}_app_service.broadcast_message_safe(
                    conversation_id=conversation_id,
                    message_info=message,
                    sender_id=str(current_user.id)
                )
                
            elif message_type == "typing":
                # 处理输入状态
                await {domain}_app_service.broadcast_typing_status(
                    conversation_id=conversation_id,
                    user_id=str(current_user.id),
                    is_typing=data.get("is_typing", False)
                )
                
    except WebSocketDisconnect:
        # 用户断开连接
        await {domain}_app_service.leave_conversation_room(conversation_id, str(current_user.id))
    except Exception as e:
        logger.error(f"WebSocket错误: {e}")
        await websocket.close(code=1011, reason="内部服务器错误")
```

### 5.2 实时通信与领域事件结合

#### **广播服务实现**
```python
# api/app/websocket/broadcasting_service.py
class BroadcastingService:
    """WebSocket广播服务"""
    
    def __init__(self):
        self.active_connections: Dict[str, List[WebSocket]] = {}
    
    async def join_conversation_room(self, conversation_id: str, user_id: str, websocket: WebSocket):
        """用户加入会话房间"""
        if conversation_id not in self.active_connections:
            self.active_connections[conversation_id] = []
        
        self.active_connections[conversation_id].append(websocket)
        logger.info(f"用户 {user_id} 加入会话 {conversation_id}")
    
    async def leave_conversation_room(self, conversation_id: str, user_id: str):
        """用户离开会话房间"""
        if conversation_id in self.active_connections:
            # 移除断开的连接
            self.active_connections[conversation_id] = [
                conn for conn in self.active_connections[conversation_id]
                if not conn.client_state.disconnected
            ]
            logger.info(f"用户 {user_id} 离开会话 {conversation_id}")
    
    async def broadcast_message(self, conversation_id: str, message: MessageInfo):
        """广播消息给会话中的所有用户"""
        if conversation_id not in self.active_connections:
            return
        
        message_data = {
            "type": "message",
            "data": message.dict()
        }
        
        # 发送给所有连接的客户端
        for connection in self.active_connections[conversation_id]:
            try:
                await connection.send_json(message_data)
            except Exception as e:
                logger.error(f"发送消息失败: {e}")
                # 移除断开的连接
                self.active_connections[conversation_id].remove(connection)
    
    async def broadcast_typing_status(self, conversation_id: str, user_id: str, is_typing: bool):
        """广播输入状态"""
        if conversation_id not in self.active_connections:
            return
        
        typing_data = {
            "type": "typing",
            "user_id": user_id,
            "is_typing": is_typing
        }
        
        for connection in self.active_connections[conversation_id]:
            try:
                await connection.send_json(typing_data)
            except Exception as e:
                logger.error(f"发送输入状态失败: {e}")
```

#### **应用服务集成广播**
```python
class ChatApplicationService(IChatApplicationService):
    async def broadcast_message_safe(
        self,
        conversation_id: str,
        message_info: MessageInfo,
        sender_id: str
    ):
        """安全地广播消息"""
        if self.broadcasting_service:
            try:
                await self.broadcasting_service.broadcast_message(conversation_id, message_info)
            except Exception as e:
                logger.error(f"广播消息失败: {e}")
                # 不抛出异常，避免影响主要业务流程
```

### 5.3 WebSocket最佳实践

#### **连接管理**
- **心跳机制**：定期发送心跳包检测连接状态
- **重连机制**：客户端自动重连处理
- **连接池**：合理管理连接数量

#### **消息格式**
```python
# 标准消息格式
{
    "type": "message|typing|system|heartbeat",
    "data": {
        # 具体消息内容
    },
    "timestamp": "2024-01-01T00:00:00Z",
    "message_id": "uuid"
}
```

#### **错误处理**
- **连接错误**：优雅处理连接断开
- **消息错误**：验证消息格式和内容
- **权限错误**：验证用户访问权限

## 6. 数据转换策略

### 6.1 转换模式选择

#### **模式1：独立转换器类（推荐）**
```python
# api/app/{domain}/converters/{domain}_converter.py
from typing import List, Optional, Dict, Any
from app.{domain}.schemas.responses import {Domain}Response, {Domain}Create
from app.{domain}.domain.entities.{domain} import {Domain}

class {Domain}Converter:
    """{domain}数据转换器"""
    
    @staticmethod
    def to_response({domain}: {Domain}) -> {Domain}Response:
        """转换{domain}实体为响应格式"""
        return {Domain}Response(
            id={domain}.id,
            title={domain}.title,
            created_at={domain}.created_at,
            updated_at={domain}.updated_at,
            metadata={domain}.metadata
        )
    
    @staticmethod
    def to_list_response({domain}s: List[{Domain}]) -> List[{Domain}Response]:
        """转换{domain}列表为响应格式"""
        return [{Domain}Converter.to_response({domain}) for {domain} in {domain}s]
    
    @staticmethod
    def from_create_request(request: {Domain}Create) -> Dict[str, Any]:
        """从创建请求转换为领域对象参数"""
        return {
            "title": request.title,
            "metadata": request.metadata or {}
        }
    
    @staticmethod
    def from_model(model) -> {Domain}:
        """从ORM模型转换为领域实体"""
        return {Domain}(
            id=model.id,
            title=model.title,
            created_at=model.created_at,
            updated_at=model.updated_at,
            metadata=model.metadata or {}
        )
    
    @staticmethod
    def to_model_dict({domain}: {Domain}) -> Dict[str, Any]:
        """转换领域实体为ORM模型字典"""
        return {
            "id": {domain}.id,
            "title": {domain}.title,
            "created_at": {domain}.created_at,
            "updated_at": {domain}.updated_at,
            "metadata": {domain}.metadata
        }
```

### 6.2 转换器职责

#### **转换器应负责的转换类型**
1. **领域实体 ↔ API Schema**: 领域对象与API请求/响应之间的转换
2. **领域实体 ↔ ORM模型**: 领域对象与数据库模型之间的转换
3. **请求数据 → 领域参数**: API请求数据转换为领域对象创建参数

#### **转换器方法命名规范**
- `to_response()`: 领域实体转换为API响应
- `to_list_response()`: 领域实体列表转换为API响应列表
- `from_create_request()`: 创建请求转换为领域对象参数
- `from_update_request()`: 更新请求转换为领域对象参数
- `from_model()`: ORM模型转换为领域实体
- `to_model_dict()`: 领域实体转换为ORM模型字典

### 6.3 转换最佳实践

- **性能优化**：批量转换使用列表推导式，避免N+1查询
- **内存管理**：大对象集合考虑使用生成器表达式
- **类型安全**：使用完整的类型注解，确保类型安全
- **错误处理**：转换失败时提供有意义的错误信息
- **一致性**：所有转换器遵循相同的命名和结构模式
- **文档化**：为每个转换方法提供清晰的文档说明

## 7. 代码实现规范

### 7.1 目录结构规范

#### **完整DDD分层目录结构**
```
api/app/{domain}/deps/{domain}.py   # 依赖注入 - 管理领域服务的依赖关系，提供接口实现
api/app/{domain}/
├── __init__.py                    # 模块入口，导出主要应用服务
├── application/                   # 应用层 - 用例编排和事务管理
│   ├── __init__.py
│   ├── {domain}_application_service.py
│   └── {sub_domain}_application_service.py
├── domain/                        # 领域层 - 核心业务逻辑
│   ├── __init__.py
│   ├── entities/                  # 聚合根和实体
│   │   ├── __init__.py
│   │   ├── {aggregate_root}.py
│   │   └── {entity}.py
│   ├── value_objects/            # 值对象
│   │   ├── __init__.py
│   │   ├── {value_object}.py
│   │   └── {enum}.py
│   ├── {domain}_domain_service.py
│   └── {sub_domain}_domain_service.py
├── infrastructure/               # 基础设施层 - 数据访问和外部服务
│   ├── __init__.py
│   ├── repositories/             # 仓储实现
│   │   ├── __init__.py
│   │   ├── {aggregate_root}_repository.py
│   │   └── {entity}_repository.py
│   ├── db/                      # 数据库相关
│   │   ├── __init__.py
│   │   └── models.py
│   └── external_services/        # 外部服务集成
│       ├── __init__.py
│       └── {external_service}.py
├── converters/                   # 数据转换层 - 格式转换
│   ├── __init__.py
│   ├── {aggregate_root}_converter.py
│   └── {entity}_converter.py
├── schemas/                      # API Schema定义
│   ├── __init__.py
│   ├── requests.py
│   └── responses.py
├── endpoints/                    # API端点定义
│   ├── __init__.py
│   └── {domain}.py
└── deps/                         # 依赖注入配置
    ├── __init__.py
    └── {domain}.py
```

#### **目录命名规范**

##### **顶层目录**
- **推荐**: 使用领域名称作为服务目录名
- **位置**: `api/app/{domain}/`
- **示例**: `consultation/`, `user/`, `order/`

##### **接口定义层目录**
- **推荐**: 使用 `interfaces/` 目录
- **职责**: 定义所有服务接口，包括仓储接口、领域服务接口、应用服务接口
- **命名**: 接口文件使用 `{type}_interfaces.py` 格式
- **位置**: 放在服务模块的顶层，便于各层引用

##### **应用层目录**
- **推荐**: 使用 `application/` 目录
- **职责**: 用例编排、事务管理、依赖注入
- **命名**: 应用服务文件使用 `{domain}_application_service.py` 格式

##### **领域层目录**
- **推荐**: 使用 `domain/` 目录
- **职责**: 核心业务逻辑、领域规则、聚合设计
- **子目录**:
  - `entities/`: 聚合根和实体
  - `value_objects/`: 值对象和枚举
  - 领域服务直接放在 `domain/` 目录下

##### **基础设施层目录**
- **推荐**: 使用 `infrastructure/` 目录
- **职责**: 数据访问、外部服务集成、技术实现
- **子目录**:
  - `repositories/`: 仓储实现
  - `external_services/`: 外部服务集成

##### **转换器目录**
- **推荐**: 使用 `converters/` 目录
- **职责**: 数据格式转换、API Schema映射
- **命名**: 转换器文件使用 `{aggregate_root}_converter.py` 格式

#### **文件命名规范**

##### **聚合根和实体**
- **文件命名**: `{aggregate_root}.py`, `{entity}.py`
- **类命名**: `{AggregateRoot}`, `{Entity}`
- **示例**: `consultation.py` → `Consultation`, `plan.py` → `Plan`
- **重要**: 所有实体必须继承`BaseEntity`基类
- **要求**: 必须实现`validate()`方法和调用`super().__init__(id)`

##### **值对象**
- **文件命名**: `{value_object}.py`
- **类命名**: `{ValueObject}`
- **示例**: `consultation_status.py` → `ConsultationStatus`

##### **领域服务**
- **文件命名**: `{domain}_domain_service.py`
- **类命名**: `{Domain}DomainService`
- **示例**: `consultation_domain_service.py` → `ConsultationDomainService`

##### **应用服务**
- **文件命名**: `{domain}_application_service.py`
- **类命名**: `{Domain}ApplicationService`
- **示例**: `consultation_application_service.py` → `ConsultationApplicationService`

##### **仓储**
- **文件命名**: `{aggregate_root}_repository.py`
- **类命名**: `{AggregateRoot}Repository`
- **示例**: `consultation_repository.py` → `ConsultationRepository`

##### **转换器**
- **文件命名**: `{aggregate_root}_converter.py`
- **类命名**: `{AggregateRoot}Converter`
- **示例**: `consultation_converter.py` → `ConsultationConverter`

##### **接口文件**
- **文件命名**: `{type}_interfaces.py`
- **类命名**: `{Type}Interface` 或 `I{Type}`
- **示例**: `repository_interfaces.py` → `RepositoryInterface`, `domain_service_interfaces.py` → `IDomainService`

#### **实际示例：咨询服务模块**

```
api/app/consultation/deps/consultation.py   # 依赖注入 - 管理咨询服务依赖关系
api/app/consultation/
├── __init__.py                    # 导出主要应用服务
├── application/                   # 应用层
│   ├── __init__.py
│   ├── consultation_application_service.py
│   ├── plan_generation_application_service.py
│   └── consultant_application_service.py
├── domain/                        # 领域层
│   ├── __init__.py
│   ├── entities/                  # 聚合根和实体
│   │   ├── __init__.py
│   │   ├── consultation.py       # 咨询聚合根
│   │   ├── plan.py              # 方案聚合根
│   │   └── consultant.py        # 顾问实体
│   ├── value_objects/           # 值对象
│   │   ├── __init__.py
│   │   ├── consultation_status.py # 咨询状态
│   │   └── plan_status.py       # 方案状态
│   ├── consultation_domain_service.py
│   ├── plan_generation_domain_service.py
│   └── consultant_domain_service.py
├── infrastructure/              # 基础设施层
│   ├── __init__.py
│   ├── repositories/            # 仓储
│   │   ├── __init__.py
│   │   ├── consultation_repository.py
│   │   ├── plan_repository.py
│   │   └── consultant_repository.py
│   ├── db/                     # 数据库模型
│   │   ├── __init__.py
│   │   └── models.py
│   └── external_services/       # 外部服务
│       ├── __init__.py
│       └── ai_service.py        # AI服务集成
├── converters/                  # 数据转换层
│   ├── __init__.py
│   ├── consultation_converter.py
│   ├── plan_converter.py
│   └── consultant_converter.py
├── schemas/                     # API Schema
│   ├── __init__.py
│   ├── requests.py
│   └── responses.py
├── endpoints/                   # API端点
│   ├── __init__.py
│   └── consultation.py
└── deps/                        # 依赖注入
    ├── __init__.py
    └── consultation.py
```

#### **目录结构最佳实践**

##### **1. 分层原则**
- **依赖方向**: 确保依赖方向指向领域层
- **职责分离**: 每层只负责自己的职责
- **接口隔离**: 上层通过接口依赖下层，不依赖具体实现

##### **2. 目录组织原则**
- **单一职责**: 每个目录只包含相关功能的文件
- **高内聚低耦合**: 相关功能放在一起，减少跨目录依赖
- **可扩展性**: 目录结构支持功能扩展和重构

##### **3. 命名一致性**
- **统一风格**: 所有目录和文件使用一致的命名风格
- **语义化命名**: 目录和文件名应反映其内容和用途
- **避免缩写**: 使用完整的单词，避免缩写造成歧义

##### **4. 文件组织原则**
- **按类型分组**: 相同类型的文件放在同一目录下
- **按功能分组**: 相关功能的文件可以放在同一目录下
- **避免过深嵌套**: 目录嵌套不超过4层


#### **目录结构检查清单**

##### **创建新服务时**
- [ ] 是否遵循标准DDD分层结构？
- [ ] 目录命名是否符合规范？
- [ ] 文件命名是否符合规范？
- [ ] 是否包含必要的 `__init__.py` 文件？
- [ ] 导入路径是否正确？

##### **重构现有服务时**
- [ ] 是否保持了向后兼容性？
- [ ] 是否更新了所有相关导入？
- [ ] 是否更新了文档？
- [ ] 是否进行了充分的测试？

#### **注意事项**

##### **1. 避免的反模式**
- ❌ 不要创建过深的目录嵌套
- ❌ 不要使用不一致的命名风格
- ❌ 不要将不同职责的文件混在一起
- ❌ 不要忽略 `__init__.py` 文件

##### **2. 性能考虑**
- 合理使用 `__init__.py` 文件控制导入
- 避免循环导入
- 使用延迟导入减少启动时间

##### **3. 团队协作**
- 建立团队统一的目录结构规范
- 在代码审查中检查目录结构合规性
- 定期重构和优化目录结构

### 7.2 Controller层实现
```python
@router.get("/users/{user_id}", response_model=UserResponse)
async def get_user(
    user_id: str,
    user_service: UserApplicationService = Depends(get_user_service)
) -> UserResponse:
    """获取用户信息 - 表现层只负责路由和响应"""
    return await user_service.get_user_by_id(user_id)
```

### 7.3 Application Service层实现
```python
class UserApplicationService(IUserApplicationService):
    def __init__(self, user_repository: UserRepository):
        self.user_repository = user_repository
    
    async def get_user_by_id(self, user_id: str) -> UserResponse:
        """应用服务 - 编排领域逻辑"""
        user = await self.user_repository.get_by_id(user_id)
        if not user:
            raise UserNotFoundError(user_id)
        
        return UserConverter.to_response(user)
    
    async def create_user(self, user_data: CreateUserRequest) -> UserResponse:
        """创建用户用例"""
        # 领域逻辑验证
        if await self.user_repository.exists_by_email(user_data.email):
            raise EmailAlreadyExistsError(user_data.email)
        
        # 创建领域对象
        user = User.create(
            name=user_data.name,
            email=user_data.email,
            password=user_data.password
        )
        
        # 持久化
        saved_user = await self.user_repository.save(user)
        
        # 发布领域事件
        await self.event_bus.publish(UserCreatedEvent(user_id=saved_user.id))
        
        return UserConverter.to_response(saved_user)
```

### 7.4 Domain Service层实现
```python
class UserDomainService(IUserDomainService):
    """领域服务 - 跨聚合的业务逻辑"""
    
    def __init__(self, user_repository: UserRepository, password_service: PasswordService):
        self.user_repository = user_repository
        self.password_service = password_service
    
    async def authenticate_user(self, email: str, password: str) -> Optional[User]:
        """用户认证 - 领域逻辑"""
        user = await self.user_repository.get_by_email(email)
        if not user:
            return None
        
        if not self.password_service.verify_password(password, user.password_hash):
            return None
        
        user.record_login()
        await self.user_repository.save(user)
        
        return user
```

### 7.5 Repository层实现
```python
class UserRepository(IUserRepository):
    """仓储实现 - 基础设施层"""
    
    def __init__(self, db: Session):
        self.db = db
    
    async def get_by_id(self, user_id: str) -> Optional[User]:
        """根据ID获取用户"""
        user_model = self.db.query(UserModel).filter(UserModel.id == user_id).first()
        
        if not user_model:
            return None
        
        return self._to_entity(user_model)
    
    async def save(self, user: User) -> User:
        """保存用户"""
        user_model = self._to_model(user)
        self.db.add(user_model)
        self.db.commit()
        self.db.refresh(user_model)
        
        return self._to_entity(user_model)
    
    def _to_entity(self, model: UserModel) -> User:
        """ORM模型转领域实体"""
        return User(
            id=model.id,
            name=model.name,
            email=model.email,
            password_hash=model.password_hash,
            created_at=model.created_at
        )
    
    def _to_model(self, entity: User) -> UserModel:
        """领域实体转ORM模型"""
        return UserModel(
            id=entity.id,
            name=entity.name,
            email=entity.email,
            password_hash=entity.password_hash,
            created_at=entity.created_at
        )
```

## 8. 领域建模指导

### 8.1 聚合设计原则
- **一致性边界**：聚合内的对象必须保持一致性
- **事务边界**：一个事务只能修改一个聚合
- **引用原则**：聚合间通过ID引用，不直接引用对象

### 8.2 实体设计规范

#### **8.2.1 实体继承要求**

**强制要求**：所有领域实体都必须继承`BaseEntity`基类：

```python
from app.common.domain.entities.base_entity import BaseEntity

class User(BaseEntity):
    """用户聚合根"""
    
    def __init__(self, id: str, name: str, email: str, password_hash: str, created_at: datetime):
        super().__init__(id)  # 必须调用父类构造函数
        self._name = name
        self._email = email
        self._password_hash = password_hash
        self._created_at = created_at
        self._last_login_at = None
```

**继承BaseEntity的原因**：
- **统一标识管理**：所有实体都有统一的ID管理
- **领域事件支持**：支持事件驱动架构和事件溯源
- **实体验证机制**：强制实现验证逻辑
- **相等性和哈希支持**：支持集合操作和缓存

#### **8.2.2 实体设计模式**

##### **聚合根实体设计**
```python
@dataclass
class Customer(BaseEntity):
    """客户聚合根 - 管理客户的核心业务逻辑"""
    
    user_id: str
    medical_history: Optional[str] = None
    allergies: Optional[str] = None
    preferences: Optional[str] = None
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    
    def __post_init__(self):
        """初始化后验证"""
        self.validate()  # 必须调用验证方法
    
    def validate(self) -> None:
        """验证实体状态 - 必须实现"""
        if not self.user_id:
            raise ValueError("用户ID不能为空")
        
        if self.medical_history and len(self.medical_history.strip()) > 1000:
            raise ValueError("病史信息过长，不能超过1000字符")
    
    @classmethod
    def create(cls, user_id: str, **kwargs) -> "Customer":
        """工厂方法 - 创建客户"""
        from app.common.infrastructure.db.uuid_utils import customer_id
        
        customer = cls(
            id=customer_id(),
            user_id=user_id,
            **kwargs
        )
        
        customer.validate()  # 创建后必须验证
        return customer
```

##### **普通实体设计**
```python
@dataclass
class CustomerProfile(BaseEntity):
    """客户档案实体 - 扩展客户信息"""
    
    customer_id: str
    medical_history: Optional[str] = None
    tags: Optional[str] = None
    risk_notes: List[Dict[str, Any]] = field(default_factory=list)
    
    def validate(self) -> None:
        """验证实体状态 - 必须实现"""
        if not self.customer_id:
            raise ValueError("客户ID不能为空")
    
    @classmethod
    def create(cls, customer_id: str, **kwargs) -> "CustomerProfile":
        """工厂方法 - 创建档案"""
        from app.common.infrastructure.db.uuid_utils import profile_id
        
        profile = cls(
            id=profile_id(),
            customer_id=customer_id,
            **kwargs
        )
        
        profile.validate()  # 创建后必须验证
        return profile
```

#### **8.2.3 实体设计最佳实践**

##### **1. 构造函数要求**
- **必须调用super().__init__(id)**：确保BaseEntity正确初始化
- **使用工厂方法**：通过`@classmethod create()`方法创建实体
- **延迟验证**：在`__post_init__`或工厂方法中调用验证

##### **2. 验证方法要求**
- **必须实现validate()方法**：继承自BaseEntity的抽象方法
- **业务规则验证**：验证所有业务约束和规则
- **抛出ValueError**：验证失败时抛出有意义的错误信息

##### **3. 领域事件支持**
```python
def update_medical_history(self, medical_history: str) -> None:
    """更新病史信息"""
    if medical_history and len(medical_history.strip()) > 1000:
        raise ValueError("病史信息过长，不能超过1000字符")
    
    old_value = self.medical_history
    self.medical_history = medical_history.strip() if medical_history else None
    self.updated_at = datetime.now()
    
    # 添加领域事件
    self._add_domain_event(DomainEvent(
        event_type="customer_medical_history_updated",
        aggregate_id=self.id,
        data={"old_value": old_value, "new_value": self.medical_history}
    ))
```

##### **4. 不可变性设计**
- **使用私有属性**：`_field_name`形式，通过属性访问器访问
- **提供更新方法**：通过方法更新状态，而不是直接赋值
- **状态验证**：每次状态变更都要验证

##### **5. 实体关系管理**
```python
class Customer(BaseEntity):
    """客户聚合根"""
    
    def __init__(self, id: str, user_id: str, **kwargs):
        super().__init__(id)
        self._user_id = user_id
        self._profile: Optional[CustomerProfile] = None  # 关联实体
    
    @property
    def profile(self) -> Optional[CustomerProfile]:
        """获取关联的档案"""
        return self._profile
    
    def set_profile(self, profile: CustomerProfile) -> None:
        """设置关联的档案"""
        if profile.customer_id != self.id:
            raise ValueError("档案不属于此客户")
        self._profile = profile
```

#### **8.2.4 实体设计检查清单**

创建新实体时，必须检查：

- [ ] 是否继承了`BaseEntity`？
- [ ] 是否调用了`super().__init__(id)`？
- [ ] 是否实现了`validate()`方法？
- [ ] 是否使用工厂方法创建实体？
- [ ] 是否在创建后调用验证？
- [ ] 是否支持领域事件？
- [ ] 是否提供了适当的更新方法？
- [ ] 是否使用了私有属性保护状态？

#### **8.2.5 常见错误和解决方案**

##### **错误1：忘记继承BaseEntity**
```python
# ❌ 错误：没有继承BaseEntity
@dataclass
class Customer:
    id: str
    user_id: str

# ✅ 正确：继承BaseEntity
@dataclass
class Customer(BaseEntity):
    user_id: str
```

##### **错误2：忘记调用父类构造函数**
```python
# ❌ 错误：没有调用super().__init__()
def __init__(self, id: str, user_id: str):
    self._user_id = user_id  # 缺少super().__init__(id)

# ✅ 正确：调用父类构造函数
def __init__(self, id: str, user_id: str):
    super().__init__(id)
    self._user_id = user_id
```

##### **错误3：忘记实现验证方法**
```python
# ❌ 错误：没有实现validate方法
@dataclass
class Customer(BaseEntity):
    user_id: str
    # 缺少validate方法

# ✅ 正确：实现validate方法
def validate(self) -> None:
    if not self.user_id:
        raise ValueError("用户ID不能为空")
```

#### **8.2.6 实体设计示例**

##### **完整聚合根示例**
```python
@dataclass
class Consultation(BaseEntity):
    """咨询聚合根"""
    
    title: str
    owner_id: str
    consultant_id: Optional[str] = None
    status: ConsultationStatus = ConsultationStatus.PENDING
    created_at: datetime = field(default_factory=datetime.now)
    updated_at: datetime = field(default_factory=datetime.now)
    
    def __post_init__(self):
        self.validate()
    
    def validate(self) -> None:
        if not self.title or not self.title.strip():
            raise ValueError("咨询标题不能为空")
        if not self.owner_id:
            raise ValueError("咨询所有者不能为空")
    
    @classmethod
    def create(cls, title: str, owner_id: str) -> "Consultation":
        from app.common.infrastructure.db.uuid_utils import consultation_id
        
        consultation = cls(
            id=consultation_id(),
            title=title.strip(),
            owner_id=owner_id
        )
        
        consultation.validate()
        return consultation
    
    def assign_consultant(self, consultant_id: str) -> None:
        """分配顾问"""
        if not consultant_id:
            raise ValueError("顾问ID不能为空")
        
        old_consultant = self.consultant_id
        self.consultant_id = consultant_id
        self.status = ConsultationStatus.ASSIGNED
        self.updated_at = datetime.now()
        
        # 添加领域事件
        self._add_domain_event(DomainEvent(
            event_type="consultation_consultant_assigned",
            aggregate_id=self.id,
            data={"old_consultant": old_consultant, "new_consultant": consultant_id}
        ))
```

### 8.3 值对象设计
```python
class Email(ValueObject):
    """邮箱值对象"""
    
    def __init__(self, value: str):
        if not self._is_valid(value):
            raise ValueError("邮箱格式不正确")
        self._value = value.lower()
    
    @property
    def value(self) -> str:
        return self._value
    
    def _is_valid(self, email: str) -> bool:
        return bool(re.match(r"[^@]+@[^@]+\.[^@]+", email))
    
    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Email):
            return False
        return self._value == other._value
    
    def __hash__(self) -> int:
        return hash(self._value)
```

## 9. 测试策略

### 9.1 分层测试
```python
# 领域层测试
class TestUser:
    def test_create_user_with_valid_data(self):
        user = User.create("张三", "zhangsan@example.com", "password123")
        assert user.name == "张三"
        assert user.email == "zhangsan@example.com"
    
    def test_create_user_with_invalid_email(self):
        with pytest.raises(ValueError, match="邮箱格式不正确"):
            User.create("张三", "invalid-email", "password123")

# 应用层测试
class TestUserApplicationService:
    async def test_get_user_by_id_success(self):
        user = User.create("张三", "zhangsan@example.com", "password123")
        mock_repo = Mock()
        mock_repo.get_by_id.return_value = user
        
        service = UserApplicationService(mock_repo)
        result = await service.get_user_by_id("user-id")
        
        assert isinstance(result, UserResponse)
        assert result.name == "张三"

# 基础设施层测试
class TestUserRepository:
    async def test_save_user(self):
        user = User.create("张三", "zhangsan@example.com", "password123")
        db = Session()
        repo = UserRepository(db)
        
        saved_user = await repo.save(user)
        assert saved_user.id == user.id
```

## 10. 重构指导

### 10.1 渐进式重构步骤
1. **识别领域边界**：分析现有代码，识别核心业务概念
2. **提取领域模型**：将业务逻辑从服务层提取到领域层
3. **重构数据转换**：统一使用转换器模式
4. **引入仓储模式**：抽象数据访问逻辑
5. **添加领域事件**：解耦业务逻辑

### 10.2 代码质量检查
- **依赖方向**：确保依赖指向领域层
- **业务逻辑位置**：业务规则应在领域层
- **数据转换一致性**：统一使用转换器模式
- **测试覆盖率**：每层都有对应的测试

## 11. 设计原则总结

### 11.1 DDD原则
- **领域驱动**：以业务概念为核心设计代码结构
- **聚合设计**：明确业务边界和一致性约束
- **分层架构**：清晰的职责分离和依赖方向
- **领域事件**：解耦业务逻辑，支持事件驱动

### 11.2 实体设计强制要求

#### **BaseEntity继承要求**

**重要提醒**：在创建任何领域实体时，必须严格遵循以下要求：

1. **强制继承BaseEntity**：
   ```python
   # ❌ 绝对禁止：不继承BaseEntity
   class Customer:
       pass
   
   # ✅ 必须：继承BaseEntity
   class Customer(BaseEntity):
       pass
   ```

2. **强制调用父类构造函数**：
   ```python
   # ❌ 绝对禁止：忘记调用super().__init__(id)
   def __init__(self, id: str, name: str):
       self._name = name
   
   # ✅ 必须：调用父类构造函数
   def __init__(self, id: str, name: str):
       super().__init__(id)  # 必须调用
       self._name = name
   ```

3. **强制实现验证方法**：
   ```python
   # ❌ 绝对禁止：忘记实现validate方法
   class Customer(BaseEntity):
       pass  # 缺少validate方法
   
   # ✅ 必须：实现validate方法
   def validate(self) -> None:
       if not self.user_id:
           raise ValueError("用户ID不能为空")
   ```

#### **为什么必须继承BaseEntity？**

- **架构一致性**：确保所有实体遵循相同的设计模式
- **功能完整性**：获得领域事件、验证、ID管理等基础功能
- **类型安全**：支持完整的类型检查和IDE智能提示
- **测试友好**：提供统一的测试基类和工具方法
- **维护性**：统一的接口和实现模式，便于维护和扩展

#### **AI生成代码时的检查要点**

当AI生成领域实体代码时，必须检查：

1. **导入语句**：是否导入了`BaseEntity`
2. **类定义**：是否继承了`BaseEntity`
3. **构造函数**：是否调用了`super().__init__(id)`
4. **验证方法**：是否实现了`validate()`方法
5. **工厂方法**：是否使用`@classmethod create()`模式
6. **领域事件**：是否支持事件驱动架构

**违反这些要求的代码将无法通过代码审查和测试**。

### 11.2 整洁代码原则
- **单一职责**：每个类和方法只做一件事
- **开闭原则**：对扩展开放，对修改关闭
- **依赖倒置**：依赖抽象而非具体实现
- **接口隔离**：客户端不应依赖不需要的接口
- **里氏替换**：子类可以替换父类而不影响程序正确性

### 11.3 性能考虑
- **批量操作**：使用批量查询和转换
- **延迟加载**：按需加载关联数据
- **缓存策略**：合理使用缓存减少数据库访问
- **异步处理**：非阻塞操作使用异步模式
- **可测试性**：service 层和 schema 层可独立单元测试。
- **一致性**：团队开发风格统一，减少沟通和维护成本。
- **整洁性**：减少代码冗余，便于代码阅读。
