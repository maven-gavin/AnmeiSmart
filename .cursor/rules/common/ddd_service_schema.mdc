

# DDD分层架构与数据转换规范

## 1. DDD分层架构

### 1.1 分层结构
```
┌─────────────────────────────────────┐
│           Presentation Layer        │ ← API Controllers, WebSocket Handlers, Dependencies
├─────────────────────────────────────┤
│         Application Layer           │ ← Application Services, Use Cases
├─────────────────────────────────────┤
│           Domain Layer              │ ← Domain Services, Aggregates, Value Objects
├─────────────────────────────────────┤
│        Infrastructure Layer         │ ← Repositories, External Services, ORM
└─────────────────────────────────────┘
```

### 1.2 各层职责

#### **Presentation Layer（表现层）**
- **职责**：处理HTTP请求、WebSocket消息、参数校验、权限控制
- **原则**：薄层，只负责请求路由和响应格式化
- **禁止**：直接操作领域对象或基础设施

#### **Application Layer（应用层）**
- **职责**：编排领域服务，实现用例，事务管理
- **原则**：无状态，协调领域对象完成业务用例
- **特点**：包含应用服务（Application Services）和用例（Use Cases）

#### **Domain Layer（领域层）**
- **职责**：核心业务逻辑，领域规则，领域事件
- **组成**：
  - **聚合根（Aggregate Root）**：业务一致性边界
  - **实体（Entity）**：有身份的对象
  - **值对象（Value Object）**：无身份的对象
  - **领域服务（Domain Service）**：跨聚合的业务逻辑
  - **领域事件（Domain Event）**：领域内的重要事件

#### **Infrastructure Layer（基础设施层）**
- **职责**：数据持久化，外部服务集成，技术实现
- **组成**：仓储实现、外部API客户端、消息队列等

## 2. 应用服务设计模式

### 2.1 统一应用服务模式（推荐）

#### **设计理念**
为了简化开发者体验，推荐使用统一的应用服务模式，将相关功能整合到一个服务中：

```python
class ChatApplicationService(IChatApplicationService):
    """统一的聊天应用服务 - 简化开发者体验"""
    
    def __init__(
        self,
        conversation_repository: IConversationRepository,
        message_repository: IMessageRepository,
        conversation_domain_service: IConversationDomainService,
        message_domain_service: IMessageDomainService,
        broadcasting_service: Optional[BroadcastingService] = None
    ):
        self.conversation_repository = conversation_repository
        self.message_repository = message_repository
        self.conversation_domain_service = conversation_domain_service
        self.message_domain_service = message_domain_service
        self.broadcasting_service = broadcasting_service
    
    # 会话管理用例
    async def create_conversation_use_case(self, title: str, owner_id: str, conversation_type: str = "single") -> ConversationInfo:
        """创建会话用例"""
        conversation = await self.conversation_domain_service.create_conversation(title, owner_id, conversation_type)
        saved_conversation = await self.conversation_repository.save(conversation)
        return ConversationConverter.to_response(saved_conversation)
    
    # 消息管理用例
    async def send_message_use_case(self, conversation_id: str, content: Any, message_type: str, sender_id: str, sender_type: str) -> MessageInfo:
        """发送消息用例"""
        # 验证会话访问权限
        if not await self.conversation_domain_service.verify_access(conversation_id, sender_id, sender_type):
            raise ValueError("无权访问此会话")
        
        # 创建消息
        message = await self.message_domain_service.create_text_message(conversation_id, content, sender_id, sender_type)
        saved_message = await self.message_repository.save(message)
        
        # 更新会话消息数
        updated_conversation = await self.conversation_domain_service.increment_message_count(conversation_id)
        if updated_conversation:
            await self.conversation_repository.save(updated_conversation)
        
        # 广播消息
        if self.broadcasting_service:
            await self.broadcasting_service.broadcast_message(conversation_id, saved_message)
        
        return MessageConverter.to_response(saved_message)
```

#### **优势**
- **简化开发者体验**：一个限界上下文使用一个服务处理所有相关功能
- **减少抉择难度**：不再需要在多个应用服务之间选择
- **统一接口**：所有相关功能都通过同一个服务提供
- **保持DDD原则**：仍然遵循领域驱动设计的分层架构

#### **适用场景**
- **单一业务领域**：如聊天、用户管理、订单管理等
- **功能紧密相关**：多个功能之间有强关联关系
- **团队规模较小**：便于统一管理和维护

## 3. 依赖注入配置

### 3.1 依赖注入最佳实践

#### **依赖注入配置**
创建专门的依赖注入模块：

```python
# api/app/api/deps/chat.py
from typing import Optional
from fastapi import Depends
from sqlalchemy.orm import Session

from app.db.base import get_db
from app.services.chat.application import ChatApplicationService
from app.services.chat.domain import ConversationDomainService, MessageDomainService
from app.services.chat.infrastructure import ConversationRepository, MessageRepository
from app.services.websocket.broadcasting_factory import get_broadcasting_service

def get_conversation_repository(db: Session = Depends(get_db)) -> ConversationRepository:
    """获取会话仓储实例"""
    return ConversationRepository(db)

def get_message_repository(db: Session = Depends(get_db)) -> MessageRepository:
    """获取消息仓储实例"""
    return MessageRepository(db)

def get_conversation_domain_service(
    conversation_repository: ConversationRepository = Depends(get_conversation_repository)
) -> ConversationDomainService:
    """获取会话领域服务实例"""
    return ConversationDomainService(conversation_repository)

def get_message_domain_service(
    message_repository: MessageRepository = Depends(get_message_repository)
) -> MessageDomainService:
    """获取消息领域服务实例"""
    return MessageDomainService(message_repository)

def get_chat_application_service(
    conversation_repository: ConversationRepository = Depends(get_conversation_repository),
    message_repository: MessageRepository = Depends(get_message_repository),
    conversation_domain_service: ConversationDomainService = Depends(get_conversation_domain_service),
    message_domain_service: MessageDomainService = Depends(get_message_domain_service),
    broadcasting_service: Optional[BroadcastingService] = Depends(get_broadcasting_service)
) -> ChatApplicationService:
    """获取聊天应用服务实例"""
    return ChatApplicationService(
        conversation_repository=conversation_repository,
        message_repository=message_repository,
        conversation_domain_service=conversation_domain_service,
        message_domain_service=message_domain_service,
        broadcasting_service=broadcasting_service
    )
```

#### **避免循环依赖**
- **延迟导入**：在函数内部导入避免循环依赖
- **接口抽象**：使用抽象接口而不是具体实现
- **依赖方向**：确保依赖方向指向领域层

```python
# 避免循环依赖的示例
def get_service_with_lazy_import():
    # 延迟导入避免循环依赖
    from app.services.some_service import SomeService
    return SomeService()
```

#### **生命周期管理**
- **单例模式**：对于无状态服务使用单例
- **工厂模式**：对于有状态服务使用工厂
- **作用域管理**：合理管理依赖的作用域

## 4. 错误处理分层策略

### 4.1 分层错误处理原则

#### **表现层错误处理**
表现层负责捕获和转换异常，提供统一的错误响应：

```python
@router.post("/conversations", response_model=ConversationInfo)
async def create_conversation(
    conversation_in: ConversationCreate,
    current_user: User = Depends(get_current_user),
    chat_app_service: ChatApplicationService = Depends(get_chat_application_service)
):
    """创建新会话 - 表现层只负责请求路由和响应格式化"""
    try:
        conversation = await chat_app_service.create_conversation_use_case(
            title=conversation_in.title,
            owner_id=str(current_user.id),
            conversation_type=conversation_in.conversation_type
        )
        return conversation
        
    except ValueError as e:
        # 业务逻辑错误 - 400 Bad Request
        raise HTTPException(status_code=400, detail=str(e))
    except PermissionError as e:
        # 权限错误 - 403 Forbidden
        raise HTTPException(status_code=403, detail=str(e))
    except Exception as e:
        # 系统错误 - 500 Internal Server Error
        logger.error(f"创建会话失败: {e}")
        raise HTTPException(status_code=500, detail="创建会话失败")
```

#### **应用层错误处理**
应用层抛出领域异常，不处理HTTP状态码：

```python
class ChatApplicationService(IChatApplicationService):
    async def create_conversation_use_case(self, title: str, owner_id: str, conversation_type: str = "single") -> ConversationInfo:
        """创建会话用例"""
        try:
            # 领域逻辑验证
            if not title or not title.strip():
                raise ValueError("会话标题不能为空")
            
            # 调用领域服务
            conversation = await self.conversation_domain_service.create_conversation(title, owner_id, conversation_type)
            saved_conversation = await self.conversation_repository.save(conversation)
            
            return ConversationConverter.to_response(saved_conversation)
            
        except ValueError:
            # 重新抛出业务异常
            raise
        except Exception as e:
            # 记录系统异常并重新抛出
            logger.error(f"应用服务创建会话失败: {e}")
            raise
```

#### **领域层错误处理**
领域层抛出具体的领域异常：

```python
class ConversationDomainService(IConversationDomainService):
    async def create_conversation(self, title: str, owner_id: str, conversation_type: str = "single") -> Conversation:
        """创建会话 - 领域逻辑"""
        # 领域规则验证
        if not title or not title.strip():
            raise ValueError("会话标题不能为空")
        
        if not owner_id:
            raise ValueError("会话所有者不能为空")
        
        # 检查用户是否已有同名会话
        if await self.conversation_repository.exists_by_title_and_owner(title.strip(), owner_id):
            raise ValueError(f"会话标题 '{title}' 已存在")
        
        # 创建领域对象
        conversation = Conversation.create(
            title=title.strip(),
            owner_id=owner_id,
            conversation_type=conversation_type
        )
        
        return conversation
```

### 4.2 统一错误响应格式

#### **错误响应Schema**
```python
class ErrorResponse(BaseModel):
    error: str
    message: str
    details: Optional[Dict[str, Any]] = None
    timestamp: datetime = Field(default_factory=datetime.utcnow)
    request_id: Optional[str] = None

class ValidationErrorResponse(BaseModel):
    error: str = "validation_error"
    message: str
    field_errors: List[Dict[str, str]]
    timestamp: datetime = Field(default_factory=datetime.utcnow)
```

#### **全局异常处理器**
```python
from fastapi import Request
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError

@app.exception_handler(ValueError)
async def value_error_handler(request: Request, exc: ValueError):
    """处理业务逻辑错误"""
    return JSONResponse(
        status_code=400,
        content=ErrorResponse(
            error="business_error",
            message=str(exc),
            request_id=request.headers.get("X-Request-ID")
        ).dict()
    )

@app.exception_handler(RequestValidationError)
async def validation_error_handler(request: Request, exc: RequestValidationError):
    """处理请求验证错误"""
    field_errors = []
    for error in exc.errors():
        field_errors.append({
            "field": ".".join(str(loc) for loc in error["loc"]),
            "message": error["msg"]
        })
    
    return JSONResponse(
        status_code=422,
        content=ValidationErrorResponse(
            message="请求参数验证失败",
            field_errors=field_errors,
            request_id=request.headers.get("X-Request-ID")
        ).dict()
    )
```

## 5. WebSocket集成架构

### 5.1 WebSocket在DDD架构中的位置

#### **架构设计**
WebSocket服务位于表现层，与HTTP API并列：

```
┌─────────────────────────────────────┐
│           Presentation Layer        │ ← HTTP Controllers + WebSocket Handlers
├─────────────────────────────────────┤
│         Application Layer           │ ← Application Services
├─────────────────────────────────────┤
│           Domain Layer              │ ← Domain Services + Entities
├─────────────────────────────────────┤
│        Infrastructure Layer         │ ← Repositories + Broadcasting Service
└─────────────────────────────────────┘
```

#### **WebSocket处理器实现**
```python
# api/app/api/v1/endpoints/websocket.py
from fastapi import WebSocket, WebSocketDisconnect, Depends
from app.core.security import get_current_user_ws
from app.services.chat.application import ChatApplicationService

@router.websocket("/ws/{conversation_id}")
async def websocket_endpoint(
    websocket: WebSocket,
    conversation_id: str,
    current_user: User = Depends(get_current_user_ws),
    chat_app_service: ChatApplicationService = Depends(get_chat_application_service)
):
    """WebSocket连接处理"""
    await websocket.accept()
    
    try:
        # 验证用户对会话的访问权限
        if not await chat_app_service.verify_conversation_access(conversation_id, str(current_user.id)):
            await websocket.close(code=4003, reason="无权访问此会话")
            return
        
        # 加入会话房间
        await chat_app_service.join_conversation_room(conversation_id, str(current_user.id), websocket)
        
        # 处理消息
        while True:
            data = await websocket.receive_json()
            message_type = data.get("type")
            
            if message_type == "message":
                # 处理用户消息
                message = await chat_app_service.send_message_use_case(
                    conversation_id=conversation_id,
                    content=data.get("content"),
                    message_type="text",
                    sender_id=str(current_user.id),
                    sender_type="customer"
                )
                
                # 广播消息给会话中的所有用户
                await chat_app_service.broadcast_message_safe(
                    conversation_id=conversation_id,
                    message_info=message,
                    sender_id=str(current_user.id)
                )
                
            elif message_type == "typing":
                # 处理输入状态
                await chat_app_service.broadcast_typing_status(
                    conversation_id=conversation_id,
                    user_id=str(current_user.id),
                    is_typing=data.get("is_typing", False)
                )
                
    except WebSocketDisconnect:
        # 用户断开连接
        await chat_app_service.leave_conversation_room(conversation_id, str(current_user.id))
    except Exception as e:
        logger.error(f"WebSocket错误: {e}")
        await websocket.close(code=1011, reason="内部服务器错误")
```

### 5.2 实时通信与领域事件结合

#### **广播服务实现**
```python
# api/app/services/websocket/broadcasting_service.py
class BroadcastingService:
    """WebSocket广播服务"""
    
    def __init__(self):
        self.active_connections: Dict[str, List[WebSocket]] = {}
    
    async def join_conversation_room(self, conversation_id: str, user_id: str, websocket: WebSocket):
        """用户加入会话房间"""
        if conversation_id not in self.active_connections:
            self.active_connections[conversation_id] = []
        
        self.active_connections[conversation_id].append(websocket)
        logger.info(f"用户 {user_id} 加入会话 {conversation_id}")
    
    async def leave_conversation_room(self, conversation_id: str, user_id: str):
        """用户离开会话房间"""
        if conversation_id in self.active_connections:
            # 移除断开的连接
            self.active_connections[conversation_id] = [
                conn for conn in self.active_connections[conversation_id]
                if not conn.client_state.disconnected
            ]
            logger.info(f"用户 {user_id} 离开会话 {conversation_id}")
    
    async def broadcast_message(self, conversation_id: str, message: MessageInfo):
        """广播消息给会话中的所有用户"""
        if conversation_id not in self.active_connections:
            return
        
        message_data = {
            "type": "message",
            "data": message.dict()
        }
        
        # 发送给所有连接的客户端
        for connection in self.active_connections[conversation_id]:
            try:
                await connection.send_json(message_data)
            except Exception as e:
                logger.error(f"发送消息失败: {e}")
                # 移除断开的连接
                self.active_connections[conversation_id].remove(connection)
    
    async def broadcast_typing_status(self, conversation_id: str, user_id: str, is_typing: bool):
        """广播输入状态"""
        if conversation_id not in self.active_connections:
            return
        
        typing_data = {
            "type": "typing",
            "user_id": user_id,
            "is_typing": is_typing
        }
        
        for connection in self.active_connections[conversation_id]:
            try:
                await connection.send_json(typing_data)
            except Exception as e:
                logger.error(f"发送输入状态失败: {e}")
```

#### **应用服务集成广播**
```python
class ChatApplicationService(IChatApplicationService):
    async def broadcast_message_safe(
        self,
        conversation_id: str,
        message_info: MessageInfo,
        sender_id: str
    ):
        """安全地广播消息"""
        if self.broadcasting_service:
            try:
                await self.broadcasting_service.broadcast_message(conversation_id, message_info)
            except Exception as e:
                logger.error(f"广播消息失败: {e}")
                # 不抛出异常，避免影响主要业务流程
```

### 5.3 WebSocket最佳实践

#### **连接管理**
- **心跳机制**：定期发送心跳包检测连接状态
- **重连机制**：客户端自动重连处理
- **连接池**：合理管理连接数量

#### **消息格式**
```python
# 标准消息格式
{
    "type": "message|typing|system|heartbeat",
    "data": {
        # 具体消息内容
    },
    "timestamp": "2024-01-01T00:00:00Z",
    "message_id": "uuid"
}
```

#### **错误处理**
- **连接错误**：优雅处理连接断开
- **消息错误**：验证消息格式和内容
- **权限错误**：验证用户访问权限

## 6. 数据转换策略

### 6.1 目录结构规范

#### **完整DDD分层目录结构**
```
api/app/api/deps/{domain}.py       # 依赖注入 - 管理领域服务的依赖关系，提供接口实现
api/app/services/{domain}/
├── __init__.py                    # 模块入口，导出主要应用服务
├── interfaces/                    # 接口定义层 - 定义所有服务接口
│   ├── __init__.py
│   ├── repository_interfaces.py  # 仓储接口定义
│   ├── domain_service_interfaces.py  # 领域服务接口定义
│   └── application_service_interfaces.py  # 应用服务接口定义
├── application/                   # 应用层 - 用例编排和事务管理
│   ├── __init__.py
│   ├── {domain}_application_service.py
│   └── {sub_domain}_application_service.py
├── domain/                        # 领域层 - 核心业务逻辑
│   ├── __init__.py
│   ├── entities/                  # 聚合根和实体
│   │   ├── __init__.py
│   │   ├── {aggregate_root}.py
│   │   └── {entity}.py
│   ├── value_objects/            # 值对象
│   │   ├── __init__.py
│   │   ├── {value_object}.py
│   │   └── {enum}.py
│   ├── {domain}_domain_service.py
│   └── {sub_domain}_domain_service.py
├── infrastructure/               # 基础设施层 - 数据访问和外部服务
│   ├── __init__.py
│   ├── repositories/             # 仓储实现
│   │   ├── __init__.py
│   │   ├── {aggregate_root}_repository.py
│   │   └── {entity}_repository.py
│   └── external_services/        # 外部服务集成
│       ├── __init__.py
│       └── {external_service}.py
└── converters/                   # 数据转换层 - 格式转换
    ├── __init__.py
    ├── {aggregate_root}_converter.py
    └── {entity}_converter.py
```

#### **目录命名规范**

##### **顶层目录**
- **推荐**: 使用领域名称作为服务目录名
- **位置**: `api/app/services/{domain}/`
- **示例**: `consultation/`, `user/`, `order/`

##### **接口定义层目录**
- **推荐**: 使用 `interfaces/` 目录
- **职责**: 定义所有服务接口，包括仓储接口、领域服务接口、应用服务接口
- **命名**: 接口文件使用 `{type}_interfaces.py` 格式
- **位置**: 放在服务模块的顶层，便于各层引用

##### **应用层目录**
- **推荐**: 使用 `application/` 目录
- **职责**: 用例编排、事务管理、依赖注入
- **命名**: 应用服务文件使用 `{domain}_application_service.py` 格式

##### **领域层目录**
- **推荐**: 使用 `domain/` 目录
- **职责**: 核心业务逻辑、领域规则、聚合设计
- **子目录**:
  - `entities/`: 聚合根和实体
  - `value_objects/`: 值对象和枚举
  - 领域服务直接放在 `domain/` 目录下

##### **基础设施层目录**
- **推荐**: 使用 `infrastructure/` 目录
- **职责**: 数据访问、外部服务集成、技术实现
- **子目录**:
  - `repositories/`: 仓储实现
  - `external_services/`: 外部服务集成

##### **转换器目录**
- **推荐**: 使用 `converters/` 目录
- **职责**: 数据格式转换、API Schema映射
- **命名**: 转换器文件使用 `{aggregate_root}_converter.py` 格式

#### **文件命名规范**

##### **聚合根和实体**
- **文件命名**: `{aggregate_root}.py`, `{entity}.py`
- **类命名**: `{AggregateRoot}`, `{Entity}`
- **示例**: `consultation.py` → `Consultation`, `plan.py` → `Plan`

##### **值对象**
- **文件命名**: `{value_object}.py`
- **类命名**: `{ValueObject}`
- **示例**: `consultation_status.py` → `ConsultationStatus`

##### **领域服务**
- **文件命名**: `{domain}_domain_service.py`
- **类命名**: `{Domain}DomainService`
- **示例**: `consultation_domain_service.py` → `ConsultationDomainService`

##### **应用服务**
- **文件命名**: `{domain}_application_service.py`
- **类命名**: `{Domain}ApplicationService`
- **示例**: `consultation_application_service.py` → `ConsultationApplicationService`

##### **仓储**
- **文件命名**: `{aggregate_root}_repository.py`
- **类命名**: `{AggregateRoot}Repository`
- **示例**: `consultation_repository.py` → `ConsultationRepository`

##### **转换器**
- **文件命名**: `{aggregate_root}_converter.py`
- **类命名**: `{AggregateRoot}Converter`
- **示例**: `consultation_converter.py` → `ConsultationConverter`

##### **接口文件**
- **文件命名**: `{type}_interfaces.py`
- **类命名**: `{Type}Interface` 或 `I{Type}`
- **示例**: `repository_interfaces.py` → `RepositoryInterface`, `domain_service_interfaces.py` → `IDomainService`

#### **实际示例：咨询服务模块**

```
api/app/api/deps/consultation.py   # 依赖注入 - 管理咨询服务依赖关系
api/app/services/consultation/
├── __init__.py                    # 导出主要应用服务
├── interfaces/                    # 接口定义层
│   ├── __init__.py
│   ├── repository_interfaces.py  # 仓储接口定义
│   ├── domain_service_interfaces.py  # 领域服务接口定义
│   └── application_service_interfaces.py  # 应用服务接口定义
├── application/                   # 应用层
│   ├── __init__.py
│   ├── consultation_application_service.py
│   ├── plan_generation_application_service.py
│   └── consultant_application_service.py
├── domain/                        # 领域层
│   ├── __init__.py
│   ├── entities/                  # 聚合根和实体
│   │   ├── __init__.py
│   │   ├── consultation.py       # 咨询聚合根
│   │   ├── plan.py              # 方案聚合根
│   │   └── consultant.py        # 顾问实体
│   ├── value_objects/           # 值对象
│   │   ├── __init__.py
│   │   ├── consultation_status.py # 咨询状态
│   │   └── plan_status.py       # 方案状态
│   ├── consultation_domain_service.py
│   ├── plan_generation_domain_service.py
│   └── consultant_domain_service.py
├── infrastructure/              # 基础设施层
│   ├── __init__.py
│   ├── repositories/            # 仓储
│   │   ├── __init__.py
│   │   ├── consultation_repository.py
│   │   ├── plan_repository.py
│   │   └── consultant_repository.py
│   └── external_services/       # 外部服务
│       ├── __init__.py
│       └── ai_service.py        # AI服务集成
└── converters/                  # 数据转换层
    ├── __init__.py
    ├── consultation_converter.py
    ├── plan_converter.py
    └── consultant_converter.py
```

#### **目录结构最佳实践**

##### **1. 分层原则**
- **依赖方向**: 确保依赖方向指向领域层
- **职责分离**: 每层只负责自己的职责
- **接口隔离**: 上层通过接口依赖下层，不依赖具体实现

##### **2. 目录组织原则**
- **单一职责**: 每个目录只包含相关功能的文件
- **高内聚低耦合**: 相关功能放在一起，减少跨目录依赖
- **可扩展性**: 目录结构支持功能扩展和重构

##### **3. 命名一致性**
- **统一风格**: 所有目录和文件使用一致的命名风格
- **语义化命名**: 目录和文件名应反映其内容和用途
- **避免缩写**: 使用完整的单词，避免缩写造成歧义

##### **4. 文件组织原则**
- **按类型分组**: 相同类型的文件放在同一目录下
- **按功能分组**: 相关功能的文件可以放在同一目录下
- **避免过深嵌套**: 目录嵌套不超过4层

#### **常见目录结构模式**

##### **模式1：标准DDD分层（推荐）**
```
{domain}/
├── application/
├── domain/
├── infrastructure/
└── converters/
```

##### **模式2：按功能分组**
```
{domain}/
├── core/              # 核心业务逻辑
├── application/       # 应用服务
├── infrastructure/    # 基础设施
└── shared/           # 共享组件
```

##### **模式3：按模块分组**
```
{domain}/
├── {sub_domain1}/
├── {sub_domain2}/
└── shared/
```

#### **目录结构检查清单**

##### **创建新服务时**
- [ ] 是否遵循标准DDD分层结构？
- [ ] 目录命名是否符合规范？
- [ ] 文件命名是否符合规范？
- [ ] 是否包含必要的 `__init__.py` 文件？
- [ ] 导入路径是否正确？

##### **重构现有服务时**
- [ ] 是否保持了向后兼容性？
- [ ] 是否更新了所有相关导入？
- [ ] 是否更新了文档？
- [ ] 是否进行了充分的测试？

#### **注意事项**

##### **1. 避免的反模式**
- ❌ 不要创建过深的目录嵌套
- ❌ 不要使用不一致的命名风格
- ❌ 不要将不同职责的文件混在一起
- ❌ 不要忽略 `__init__.py` 文件

##### **2. 性能考虑**
- 合理使用 `__init__.py` 文件控制导入
- 避免循环导入
- 使用延迟导入减少启动时间

##### **3. 团队协作**
- 建立团队统一的目录结构规范
- 在代码审查中检查目录结构合规性
- 定期重构和优化目录结构

### 6.2 转换模式选择

#### **模式1：独立转换器类（推荐）**
```python
# api/app/services/consultation/converters/consultation_converter.py
from typing import List, Optional, Dict, Any
from app.schemas.consultation import ConsultationResponse, ConsultationCreate
from ..domain.entities.consultation import Consultation

class ConsultationConverter:
    """咨询数据转换器"""
    
    @staticmethod
    def to_response(consultation: Consultation) -> ConsultationResponse:
        """转换咨询实体为响应格式"""
        return ConsultationResponse(
            id=consultation.id,
            customer_id=consultation.customer_id,
            consultant_id=consultation.consultant_id,
            status=consultation.status.value,
            title=consultation.title,
            created_at=consultation.created_at,
            updated_at=consultation.updated_at,
            metadata=consultation.metadata
        )
    
    @staticmethod
    def to_list_response(consultations: List[Consultation]) -> List[ConsultationResponse]:
        """转换咨询列表为响应格式"""
        return [ConsultationConverter.to_response(consultation) for consultation in consultations]
    
    @staticmethod
    def from_create_request(request: ConsultationCreate) -> Dict[str, Any]:
        """从创建请求转换为领域对象参数"""
        return {
            "customer_id": request.customer_id,
            "title": request.title,
            "metadata": request.metadata or {}
        }
    
    @staticmethod
    def from_model(model) -> Consultation:
        """从ORM模型转换为领域实体"""
        return Consultation(
            id=model.id,
            customer_id=model.customer_id,
            consultant_id=model.consultant_id,
            status=ConsultationStatus.from_string(model.status),
            title=model.title,
            created_at=model.created_at,
            updated_at=model.updated_at,
            metadata=model.metadata or {}
        )
    
    @staticmethod
    def to_model_dict(consultation: Consultation) -> Dict[str, Any]:
        """转换领域实体为ORM模型字典"""
        return {
            "id": consultation.id,
            "customer_id": consultation.customer_id,
            "consultant_id": consultation.consultant_id,
            "status": consultation.status.value,
            "title": consultation.title,
            "created_at": consultation.created_at,
            "updated_at": consultation.updated_at,
            "metadata": consultation.metadata
        }

#### **模式2：Schema内置转换（简单场景）**
```python
class UserResponse(BaseModel):
    id: str
    name: str
    email: str
    created_at: datetime
    
    @classmethod
    def from_entity(cls, user: User) -> "UserResponse":
        return cls(
            id=user.id,
            name=user.name,
            email=user.email,
            created_at=user.created_at
        )
```

#### **模式3：工厂模式（复杂聚合）**
```python
class ConversationResponseFactory:
    @staticmethod
    def create(conversation: Conversation, include_messages: bool = False) -> ConversationResponse:
        base_data = {
            "id": conversation.id,
            "title": conversation.title,
            "created_at": conversation.created_at
        }
        
        if include_messages:
            base_data["messages"] = [
                MessageConverter.to_response(msg) for msg in conversation.messages
            ]
        
        return ConversationResponse(**base_data)
```

### 6.3 转换器职责

#### **转换器应负责的转换类型**
1. **领域实体 ↔ API Schema**: 领域对象与API请求/响应之间的转换
2. **领域实体 ↔ ORM模型**: 领域对象与数据库模型之间的转换
3. **请求数据 → 领域参数**: API请求数据转换为领域对象创建参数

#### **转换器方法命名规范**
- `to_response()`: 领域实体转换为API响应
- `to_list_response()`: 领域实体列表转换为API响应列表
- `from_create_request()`: 创建请求转换为领域对象参数
- `from_update_request()`: 更新请求转换为领域对象参数
- `from_model()`: ORM模型转换为领域实体
- `to_model_dict()`: 领域实体转换为ORM模型字典

### 6.4 转换最佳实践

- **性能优化**：批量转换使用列表推导式，避免N+1查询
- **内存管理**：大对象集合考虑使用生成器表达式
- **类型安全**：使用完整的类型注解，确保类型安全
- **错误处理**：转换失败时提供有意义的错误信息
- **一致性**：所有转换器遵循相同的命名和结构模式
- **文档化**：为每个转换方法提供清晰的文档说明

## 7. 代码实现规范

### 7.1 Controller层实现
```python
@router.get("/users/{user_id}", response_model=UserResponse)
async def get_user(
    user_id: str,
    user_service: UserApplicationService = Depends(get_user_service)
) -> UserResponse:
    """获取用户信息 - 表现层只负责路由和响应"""
    return await user_service.get_user_by_id(user_id)
```

### 7.2 Application Service层实现
```python
class UserApplicationService(IUserApplicationService):
    def __init__(self, user_repository: UserRepository):
        self.user_repository = user_repository
    
    async def get_user_by_id(self, user_id: str) -> UserResponse:
        """应用服务 - 编排领域逻辑"""
        user = await self.user_repository.get_by_id(user_id)
        if not user:
            raise UserNotFoundError(user_id)
        
        return UserConverter.to_response(user)
    
    async def create_user(self, user_data: CreateUserRequest) -> UserResponse:
        """创建用户用例"""
        # 领域逻辑验证
        if await self.user_repository.exists_by_email(user_data.email):
            raise EmailAlreadyExistsError(user_data.email)
        
        # 创建领域对象
        user = User.create(
            name=user_data.name,
            email=user_data.email,
            password=user_data.password
        )
        
        # 持久化
        saved_user = await self.user_repository.save(user)
        
        # 发布领域事件
        await self.event_bus.publish(UserCreatedEvent(user_id=saved_user.id))
        
        return UserConverter.to_response(saved_user)
```

### 7.3 Domain Service层实现
```python
class UserDomainService(IUserDomainService):
    """领域服务 - 跨聚合的业务逻辑"""
    
    def __init__(self, user_repository: UserRepository, password_service: PasswordService):
        self.user_repository = user_repository
        self.password_service = password_service
    
    async def authenticate_user(self, email: str, password: str) -> Optional[User]:
        """用户认证 - 领域逻辑"""
        user = await self.user_repository.get_by_email(email)
        if not user:
            return None
        
        if not self.password_service.verify_password(password, user.password_hash):
            return None
        
        user.record_login()
        await self.user_repository.save(user)
        
        return user
```

### 7.4 Repository层实现
```python
class UserRepository(IUserRepository):
    """仓储实现 - 基础设施层"""
    
    def __init__(self, db: Session):
        self.db = db
    
    async def get_by_id(self, user_id: str) -> Optional[User]:
        """根据ID获取用户"""
        user_model = self.db.query(UserModel).filter(UserModel.id == user_id).first()
        
        if not user_model:
            return None
        
        return self._to_entity(user_model)
    
    async def save(self, user: User) -> User:
        """保存用户"""
        user_model = self._to_model(user)
        self.db.add(user_model)
        self.db.commit()
        self.db.refresh(user_model)
        
        return self._to_entity(user_model)
    
    def _to_entity(self, model: UserModel) -> User:
        """ORM模型转领域实体"""
        return User(
            id=model.id,
            name=model.name,
            email=model.email,
            password_hash=model.password_hash,
            created_at=model.created_at
        )
    
    def _to_model(self, entity: User) -> UserModel:
        """领域实体转ORM模型"""
        return UserModel(
            id=entity.id,
            name=entity.name,
            email=entity.email,
            password_hash=entity.password_hash,
            created_at=entity.created_at
        )
```

## 8. 领域建模指导

### 4.1 聚合设计原则
- **一致性边界**：聚合内的对象必须保持一致性
- **事务边界**：一个事务只能修改一个聚合
- **引用原则**：聚合间通过ID引用，不直接引用对象

### 4.2 实体设计
```python
class User(Entity):
    """用户聚合根"""
    
    def __init__(self, id: str, name: str, email: str, password_hash: str, created_at: datetime):
        super().__init__(id)
        self._name = name
        self._email = email
        self._password_hash = password_hash
        self._created_at = created_at
        self._last_login_at = None
    
    @property
    def name(self) -> str:
        return self._name
    
    @property
    def email(self) -> str:
        return self._email
    
    def change_name(self, new_name: str) -> None:
        """修改用户名 - 领域逻辑"""
        if not new_name.strip():
            raise ValueError("用户名不能为空")
        self._name = new_name.strip()
        self._add_domain_event(UserNameChangedEvent(self.id, new_name))
    
    def record_login(self) -> None:
        """记录登录 - 领域逻辑"""
        self._last_login_at = datetime.utcnow()
        self._add_domain_event(UserLoggedInEvent(self.id))
    
    @classmethod
    def create(cls, name: str, email: str, password: str) -> "User":
        """工厂方法 - 创建用户"""
        if not name.strip():
            raise ValueError("用户名不能为空")
        if not email or "@" not in email:
            raise ValueError("邮箱格式不正确")
        
        user_id = str(uuid.uuid4())
        password_hash = hash_password(password)
        created_at = datetime.utcnow()
        
        return cls(user_id, name.strip(), email.lower(), password_hash, created_at)
```

### 4.3 值对象设计
```python
class Email(ValueObject):
    """邮箱值对象"""
    
    def __init__(self, value: str):
        if not self._is_valid(value):
            raise ValueError("邮箱格式不正确")
        self._value = value.lower()
    
    @property
    def value(self) -> str:
        return self._value
    
    def _is_valid(self, email: str) -> bool:
        return bool(re.match(r"[^@]+@[^@]+\.[^@]+", email))
    
    def __eq__(self, other: object) -> bool:
        if not isinstance(other, Email):
            return False
        return self._value == other._value
    
    def __hash__(self) -> int:
        return hash(self._value)
```

## 9. 测试策略

### 5.1 分层测试
```python
# 领域层测试
class TestUser:
    def test_create_user_with_valid_data(self):
        user = User.create("张三", "zhangsan@example.com", "password123")
        assert user.name == "张三"
        assert user.email == "zhangsan@example.com"
    
    def test_create_user_with_invalid_email(self):
        with pytest.raises(ValueError, match="邮箱格式不正确"):
            User.create("张三", "invalid-email", "password123")

# 应用层测试
class TestUserApplicationService:
    async def test_get_user_by_id_success(self):
        user = User.create("张三", "zhangsan@example.com", "password123")
        mock_repo = Mock()
        mock_repo.get_by_id.return_value = user
        
        service = UserApplicationService(mock_repo)
        result = await service.get_user_by_id("user-id")
        
        assert isinstance(result, UserResponse)
        assert result.name == "张三"

# 基础设施层测试
class TestUserRepository:
    async def test_save_user(self):
        user = User.create("张三", "zhangsan@example.com", "password123")
        db = Session()
        repo = UserRepository(db)
        
        saved_user = await repo.save(user)
        assert saved_user.id == user.id
```

## 10. 重构指导

### 10.1 渐进式重构步骤
1. **识别领域边界**：分析现有代码，识别核心业务概念
2. **提取领域模型**：将业务逻辑从服务层提取到领域层
3. **重构数据转换**：统一使用转换器模式
4. **引入仓储模式**：抽象数据访问逻辑
5. **添加领域事件**：解耦业务逻辑

### 10.2 目录结构规范

#### **领域服务目录结构**
- **推荐**: 领域服务直接放在 `domain/` 目录下
- **位置**: `api/app/services/{domain}/domain/`
- **命名**: 每个领域服务对应一个文件

```
api/app/services/consultation/
├── domain/                       # 领域层
│   ├── __init__.py
│   ├── entities/                 # 实体
│   ├── value_objects/           # 值对象
│   ├── consultation_domain_service.py
│   ├── plan_generation_domain_service.py
│   └── consultant_domain_service.py
```

#### **领域服务职责**
- 处理跨聚合的业务逻辑
- 实现领域规则和约束
- 协调多个聚合根之间的交互
- 提供领域级别的验证和服务

### 10.3 代码质量检查
- **依赖方向**：确保依赖指向领域层
- **业务逻辑位置**：业务规则应在领域层
- **数据转换一致性**：统一使用转换器模式
- **测试覆盖率**：每层都有对应的测试

## 11. 设计原则总结

### 11.1 DDD原则
- **领域驱动**：以业务概念为核心设计代码结构
- **聚合设计**：明确业务边界和一致性约束
- **分层架构**：清晰的职责分离和依赖方向
- **领域事件**：解耦业务逻辑，支持事件驱动

### 11.2 整洁代码原则
- **单一职责**：每个类和方法只做一件事
- **开闭原则**：对扩展开放，对修改关闭
- **依赖倒置**：依赖抽象而非具体实现
- **接口隔离**：客户端不应依赖不需要的接口
- **里氏替换**：子类可以替换父类而不影响程序正确性

### 11.3 性能考虑
- **批量操作**：使用批量查询和转换
- **延迟加载**：按需加载关联数据
- **缓存策略**：合理使用缓存减少数据库访问
- **异步处理**：非阻塞操作使用异步模式
- **可测试性**：service 层和 schema 层可独立单元测试。
- **一致性**：团队开发风格统一，减少沟通和维护成本。
- **整洁性**：减少代码冗余，便于代码阅读。
